// src/index.tsx
import {
  Actor,
  HttpAgent
} from "@dfinity/agent";
import {
  useEffect,
  useState,
  createContext,
  useContext
} from "react";
import "@dfinity/candid";
import { jsx } from "react/jsx-runtime";
function createActorContext() {
  return createContext({ actor: void 0 });
}
var AgentHTTPResponseError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = "AgentHTTPResponseError";
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
function isAgentHTTPResponseError(error) {
  return error instanceof Error && error.name === "AgentHTTPResponseError";
}
function isIdentityExpiredError(error) {
  if (!isAgentHTTPResponseError(error))
    return false;
  if (error.response.status === 400) {
    if (error.message.includes("Specified sender delegation has expired")) {
      return true;
    }
  }
  return false;
}
function createUseActorHook(context) {
  return function useActor() {
    const actorContext = useContext(context);
    if (!actorContext) {
      throw new Error("useActor must be used within an ActorProvider");
    }
    return actorContext;
  };
}
function ActorProvider({
  httpAgentOptions,
  actorOptions,
  context,
  identity,
  idlFactory,
  canisterId,
  children,
  onRequest,
  onResponse,
  onRequestError,
  onResponseError
}) {
  const [actor, setActor] = useState();
  useEffect(() => {
    function createInterceptorProxy(_actor) {
      return new Proxy(_actor, {
        get(target, prop, receiver) {
          const originalProperty = Reflect.get(target, prop, receiver);
          if (typeof originalProperty === "function") {
            return async (...args) => {
              try {
                if (onRequest) {
                  args = onRequest({ methodName: prop, args });
                }
                const response = await originalProperty.apply(this, args);
                if (onResponse) {
                  return onResponse({
                    methodName: prop,
                    args,
                    response
                  });
                }
                return response;
              } catch (error) {
                if (error instanceof TypeError) {
                  if (onRequestError)
                    error = onRequestError({
                      methodName: prop,
                      args,
                      error
                    });
                } else {
                  if (onResponseError)
                    error = onResponseError({
                      methodName: prop,
                      args,
                      error
                    });
                }
                throw error;
              }
            };
          }
          return originalProperty;
        }
      });
    }
    (async () => {
      if (!identity || !idlFactory || !canisterId || !context)
        return;
      const agent = new HttpAgent({ identity, ...httpAgentOptions });
      if (process.env.DFX_NETWORK !== "ic") {
        agent.fetchRootKey().catch((err) => {
          console.warn(
            "Unable to fetch root key. Check to ensure that your local replica is running"
          );
          console.error(err);
        });
      }
      const _actor = Actor.createActor(idlFactory, {
        agent,
        canisterId,
        ...actorOptions
      });
      setActor(createInterceptorProxy(_actor));
    })();
  }, [
    identity,
    httpAgentOptions,
    actorOptions,
    idlFactory,
    canisterId,
    context,
    onRequest,
    onResponse,
    onRequestError,
    onResponseError
  ]);
  return /* @__PURE__ */ jsx(context.Provider, { value: { actor }, children });
}
export {
  ActorProvider,
  AgentHTTPResponseError,
  createActorContext,
  createUseActorHook,
  isAgentHTTPResponseError,
  isIdentityExpiredError
};
